<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reachy Mini 辦公室助手模擬器</title>
<style>
/* ── 全域樣式 ───────────────────────────────────── */
:root {
  --bg: #1e1e28;
  --panel-bg: #23262f;
  --panel-border: #3c4050;
  --text: #dce1e6;
  --text-dim: #828794;
  --text-highlight: #78e6b4;
  --accent: #50dc7a;
  --accent-blue: #50b4ff;
  --person-color: #ffb43c;
  --event-person: #ffc850;
  --event-calendar: #b482ff;
  --event-robot: #50dc96;
  --event-leave: #ff6464;
  --event-user: #dce1e6;
  --cell-empty: #3c3f46;
  --cell-wall: #505562;
  --cell-door: #8caac8;
  --cell-desk: #786446;
  --cell-chair: #64825a;
  --cell-charger: #ffdc3c;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang TC',
    'Microsoft JhengHei', sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
}

/* ── 頂部標題列 ──────────────────────────────────── */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
  background: var(--panel-bg);
  border-bottom: 1px solid var(--panel-border);
  height: 44px;
}

.header h1 {
  font-size: 16px;
  color: var(--text-highlight);
  font-weight: 600;
}

.header .status-bar {
  display: flex;
  align-items: center;
  gap: 16px;
  font-size: 13px;
}

.header .status-bar .time {
  color: var(--accent);
  font-weight: 600;
  font-size: 15px;
}

.header .ws-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #ff4444;
  transition: background 0.3s;
}

.header .ws-indicator.connected { background: var(--accent); }

/* ── Tab 列 ─────────────────────────────────────── */
.tab-bar {
  display: flex;
  background: var(--panel-bg);
  border-bottom: 1px solid var(--panel-border);
}

.tab-bar .tab {
  padding: 6px 20px;
  font-size: 13px;
  color: var(--text-dim);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
}

.tab-bar .tab:hover { color: var(--text); }
.tab-bar .tab.active {
  color: var(--text-highlight);
  border-bottom-color: var(--text-highlight);
}

/* ── 主要佈局 ────────────────────────────────────── */
.main {
  display: flex;
  height: calc(100vh - 44px - 32px);
}

.map-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  min-width: 0;
}

.map-area canvas {
  display: block;
  cursor: crosshair;
}

/* 3D 容器 */
#three-container {
  width: 100%;
  height: 100%;
  display: none;
}

.panel {
  width: 340px;
  background: var(--panel-bg);
  border-left: 1px solid var(--panel-border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
}

/* ── 面板區塊 ────────────────────────────────────── */
.panel-section {
  padding: 10px 14px;
  border-bottom: 1px solid var(--panel-border);
}

.panel-section h3 {
  font-size: 13px;
  color: var(--text-highlight);
  margin-bottom: 6px;
  font-weight: 600;
}

.panel-section .info-row {
  font-size: 12px;
  padding: 2px 0;
  color: var(--text);
}

.panel-section .info-row .label {
  color: var(--text-dim);
  display: inline-block;
  width: 60px;
}

.panel-section .info-row.moving { color: var(--accent-blue); }
.panel-section .info-row.idle { color: var(--text-dim); }

/* ── 控制列 ──────────────────────────────────────── */
.controls {
  display: flex;
  gap: 6px;
  padding: 8px 14px;
  border-bottom: 1px solid var(--panel-border);
  flex-wrap: wrap;
}

.controls button {
  padding: 4px 12px;
  font-size: 12px;
  border: 1px solid var(--panel-border);
  background: var(--bg);
  color: var(--text);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
}

.controls button:hover {
  background: var(--panel-border);
  color: var(--text-highlight);
}

.controls button.active {
  background: var(--text-highlight);
  color: var(--bg);
  border-color: var(--text-highlight);
}

.speed-display {
  font-size: 12px;
  color: var(--text-dim);
  align-self: center;
  margin-left: 4px;
}

/* ── 行事曆 ──────────────────────────────────────── */
.meeting-item {
  font-size: 12px;
  padding: 2px 0;
}

.meeting-item.current { color: #ff8282; font-weight: 600; }
.meeting-item.next { color: var(--text-dim); }
.meeting-item.future { color: var(--text-dim); opacity: 0.6; }

/* ── 人物列表 ────────────────────────────────────── */
.person-item {
  font-size: 12px;
  color: var(--person-color);
  padding: 1px 0;
}

.person-item.empty { color: var(--text-dim); }

/* ── 事件日誌 ────────────────────────────────────── */
.event-log {
  flex: 1;
  overflow-y: auto;
  padding: 8px 14px;
  font-size: 11px;
  line-height: 1.6;
}

.event-log::-webkit-scrollbar { width: 4px; }
.event-log::-webkit-scrollbar-thumb { background: var(--panel-border); border-radius: 2px; }

.event-log .event {
  padding: 1px 0;
  word-break: break-word;
}

.event-log .event .event-time {
  color: var(--text-dim);
  margin-right: 4px;
}

.event-log .event.cat-person .event-msg { color: var(--event-person); }
.event-log .event.cat-calendar .event-msg { color: var(--event-calendar); }
.event-log .event.cat-robot .event-msg { color: var(--event-robot); }
.event-log .event.cat-leave .event-msg { color: var(--event-leave); }
.event-log .event.cat-user .event-msg { color: var(--event-user); }
.event-log .event.cat-system .event-msg { color: var(--text-dim); }

/* ── 文字輸入 ────────────────────────────────────── */
.speak-input {
  display: flex;
  padding: 8px 14px;
  gap: 6px;
  border-top: 1px solid var(--panel-border);
}

.speak-input input {
  flex: 1;
  padding: 6px 10px;
  font-size: 13px;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  outline: none;
}

.speak-input input:focus { border-color: var(--text-highlight); }
.speak-input input::placeholder { color: var(--text-dim); }

.speak-input button {
  padding: 6px 14px;
  font-size: 13px;
  background: var(--text-highlight);
  color: var(--bg);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 600;
}

.speak-input button:hover { opacity: 0.85; }

/* ── 格子提示 ────────────────────────────────────── */
.cell-tooltip {
  position: absolute;
  background: rgba(35, 38, 47, 0.95);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 11px;
  pointer-events: none;
  display: none;
  z-index: 100;
  white-space: nowrap;
}

/* ── 可折疊面板 ────────────────────────────────────── */
.collapsible-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  user-select: none;
}

.collapsible-header h3 { margin-bottom: 0; }

.collapsible-header .toggle-icon {
  font-size: 10px;
  color: var(--text-dim);
  transition: transform 0.2s;
}

.collapsible-header .toggle-icon.open { transform: rotate(90deg); }

.collapsible-body {
  overflow: hidden;
  max-height: 0;
  transition: max-height 0.2s ease-out;
}

.collapsible-body.open {
  max-height: 600px;
}

/* ── 馬達 checkbox ──────────────────────────────────── */
.motor-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2px 8px;
  margin-top: 4px;
}

.motor-grid label {
  font-size: 11px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
}

.motor-grid input[type="checkbox"] {
  accent-color: var(--accent);
}

/* ── 滑桿 ──────────────────────────────────────────── */
.slider-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 4px;
  font-size: 11px;
}

.slider-row input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  height: 4px;
}

.slider-row .slider-val {
  min-width: 32px;
  text-align: right;
  color: var(--text-dim);
}

.slider-row select {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--panel-border);
  border-radius: 3px;
  font-size: 11px;
  padding: 2px 4px;
}

/* ── 小按鈕組 ────────────────────────────────────────── */
.btn-group {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-top: 4px;
}

.btn-group button, .btn-sm {
  padding: 3px 10px;
  font-size: 11px;
  border: 1px solid var(--panel-border);
  background: var(--bg);
  color: var(--text);
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-group button:hover, .btn-sm:hover {
  background: var(--panel-border);
  color: var(--text-highlight);
}

.btn-group button.active-btn {
  background: var(--accent);
  color: var(--bg);
  border-color: var(--accent);
}

.btn-group button.recording {
  background: #ff4444;
  color: #fff;
  border-color: #ff4444;
}

/* ── 數據網格 ────────────────────────────────────────── */
.data-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 1px 8px;
  font-size: 11px;
  margin-top: 4px;
}

.data-grid .data-label {
  color: var(--text-dim);
}

.data-grid .data-value {
  color: var(--text);
  font-family: 'SF Mono', 'Consolas', monospace;
}

/* ── 狀態指示圓點 ──────────────────────────────────── */
.status-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 4px;
}

.status-dot.on { background: var(--accent); }
.status-dot.off { background: #ff4444; }

/* ── 響應式 ──────────────────────────────────────── */
@media (max-width: 800px) {
  .main { flex-direction: column; }
  .panel {
    width: 100%;
    height: 50%;
    border-left: none;
    border-top: 1px solid var(--panel-border);
  }
}
</style>
</head>
<body>

<!-- 頂部標題列 -->
<div class="header">
  <h1>Reachy Mini 辦公室助手模擬器</h1>
  <div class="status-bar">
    <span class="time" id="office-time">--:--</span>
    <span id="sim-info" style="color: var(--text-dim);">模擬秒: 0</span>
    <div class="ws-indicator" id="ws-indicator" title="WebSocket 狀態"></div>
  </div>
</div>

<!-- Tab 列 -->
<div class="tab-bar">
  <div class="tab active" data-tab="2d">2D 地圖</div>
  <div class="tab" data-tab="3d">3D 視覺化</div>
</div>

<!-- 主要區域 -->
<div class="main">
  <!-- 地圖/3D 區域 -->
  <div class="map-area">
    <canvas id="map-canvas"></canvas>
    <div id="three-container"></div>
    <div class="cell-tooltip" id="cell-tooltip"></div>
  </div>

  <!-- 右側面板 -->
  <div class="panel">
    <!-- 控制 -->
    <div class="controls">
      <button id="btn-pause">暫停</button>
      <button id="btn-resume">繼續</button>
      <button id="btn-speed-down">-</button>
      <span class="speed-display" id="speed-display">1.0x</span>
      <button id="btn-speed-up">+</button>
      <button id="btn-reset">重啟</button>
    </div>

    <!-- 機器人狀態 -->
    <div class="panel-section" id="robot-status">
      <h3>機器人狀態</h3>
      <div class="info-row"><span class="label">位置:</span> <span id="robot-pos">--</span></div>
      <div class="info-row"><span class="label">狀態:</span> <span id="robot-move">--</span></div>
      <div class="info-row"><span class="label">天線:</span> <span id="robot-ant">--</span></div>
      <div class="info-row"><span class="label">頭部:</span> <span id="robot-head">--</span></div>
      <div class="info-row"><span class="label">喚醒:</span> <span id="robot-awake">--</span></div>
    </div>

    <!-- 喚醒/睡眠 + 馬達控制 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="motor-panel-body">
        <h3>馬達控制</h3>
        <span class="toggle-icon">&#9654;</span>
      </div>
      <div class="collapsible-body" id="motor-panel-body">
        <div class="btn-group" style="margin-top:6px;">
          <button id="btn-wake-sleep">Wake Up</button>
        </div>
        <div class="motor-grid" id="motor-grid">
          <label><input type="checkbox" data-motor="head_roll" checked> head_roll</label>
          <label><input type="checkbox" data-motor="head_pitch" checked> head_pitch</label>
          <label><input type="checkbox" data-motor="head_yaw" checked> head_yaw</label>
          <label><input type="checkbox" data-motor="antenna_right" checked> ant_right</label>
          <label><input type="checkbox" data-motor="antenna_left" checked> ant_left</label>
          <label><input type="checkbox" data-motor="body_yaw" checked> body_yaw</label>
        </div>
      </div>
    </div>

    <!-- 插值控制 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="interp-panel-body">
        <h3>插值控制</h3>
        <span class="toggle-icon">&#9654;</span>
      </div>
      <div class="collapsible-body" id="interp-panel-body">
        <div class="slider-row" style="margin-top:6px;">
          <span>方法:</span>
          <select id="interp-method">
            <option value="MIN_JERK" selected>MIN_JERK</option>
            <option value="LINEAR">LINEAR</option>
            <option value="EASE">EASE</option>
            <option value="CARTOON">CARTOON</option>
          </select>
        </div>
        <div class="slider-row">
          <span>時長:</span>
          <input type="range" id="interp-duration" min="0.1" max="5.0" step="0.1" value="1.0">
          <span class="slider-val" id="interp-duration-val">1.0s</span>
        </div>
        <div class="slider-row">
          <span>Yaw:</span>
          <input type="range" id="interp-yaw" min="-45" max="45" step="1" value="0">
          <span class="slider-val" id="interp-yaw-val">0</span>
        </div>
        <div class="slider-row">
          <span>Pitch:</span>
          <input type="range" id="interp-pitch" min="-30" max="30" step="1" value="0">
          <span class="slider-val" id="interp-pitch-val">0</span>
        </div>
        <div class="btn-group">
          <button id="btn-goto-target">Go</button>
        </div>
      </div>
    </div>

    <!-- 音訊面板 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="audio-panel-body">
        <h3>音訊</h3>
        <span class="toggle-icon">&#9654;</span>
      </div>
      <div class="collapsible-body" id="audio-panel-body">
        <div class="btn-group" style="margin-top:6px;">
          <button id="btn-play-sound">Play Sound</button>
          <button id="btn-record-toggle">Rec Start</button>
        </div>
        <div class="info-row" style="margin-top:4px;">
          <span class="label">DoA:</span> <span id="audio-doa">--</span>
        </div>
        <div class="info-row">
          <span class="label">Sound:</span> <span id="audio-sound-status">--</span>
        </div>
        <div class="info-row">
          <span class="label">Rec:</span> <span id="audio-rec-status">--</span>
        </div>
      </div>
    </div>

    <!-- 動作面板 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="motion-panel-body">
        <h3>動作錄製/回放</h3>
        <span class="toggle-icon">&#9654;</span>
      </div>
      <div class="collapsible-body" id="motion-panel-body">
        <div class="btn-group" style="margin-top:6px;">
          <button id="btn-motion-rec-toggle">Rec Start</button>
          <button id="btn-motion-play">Play</button>
          <button id="btn-motion-stop">Stop</button>
        </div>
        <div class="slider-row">
          <span>Speed:</span>
          <input type="range" id="motion-speed" min="0.1" max="3.0" step="0.1" value="1.0">
          <span class="slider-val" id="motion-speed-val">1.0x</span>
        </div>
        <div class="info-row" style="margin-top:4px;">
          <span class="label">Status:</span> <span id="motion-status">Idle</span>
        </div>
      </div>
    </div>

    <!-- IMU 顯示 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="imu-panel-body">
        <h3>IMU 數據</h3>
        <span class="toggle-icon">&#9654;</span>
      </div>
      <div class="collapsible-body" id="imu-panel-body">
        <div class="data-grid" id="imu-data">
          <span class="data-label">Accel:</span><span class="data-value" id="imu-accel">--</span>
          <span class="data-label">Gyro:</span><span class="data-value" id="imu-gyro">--</span>
          <span class="data-label">Quat:</span><span class="data-value" id="imu-quat">--</span>
        </div>
      </div>
    </div>

    <!-- 關節角度 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="joints-panel-body">
        <h3>關節角度</h3>
        <span class="toggle-icon">&#9654;</span>
      </div>
      <div class="collapsible-body" id="joints-panel-body">
        <div class="data-grid" id="joints-data">
          <span class="data-label">head_roll:</span><span class="data-value" id="joint-head-roll">--</span>
          <span class="data-label">head_pitch:</span><span class="data-value" id="joint-head-pitch">--</span>
          <span class="data-label">head_yaw:</span><span class="data-value" id="joint-head-yaw">--</span>
          <span class="data-label">ant_right:</span><span class="data-value" id="joint-ant-right">--</span>
          <span class="data-label">ant_left:</span><span class="data-value" id="joint-ant-left">--</span>
          <span class="data-label">body_yaw:</span><span class="data-value" id="joint-body-yaw">--</span>
        </div>
      </div>
    </div>

    <!-- 人物感知 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="perception-panel-body">
        <h3>人物感知</h3>
        <span class="toggle-icon open">&#9654;</span>
      </div>
      <div class="collapsible-body open" id="perception-panel-body">
        <div class="info-row" style="margin-top:4px;">
          <span class="label">模式:</span> <span id="perception-mode">--</span>
        </div>
        <div class="info-row">
          <span class="label">狀態:</span> <span id="perception-status">--</span>
        </div>
        <div class="info-row">
          <span class="label">人數:</span> <span id="perception-count">0</span>
        </div>
        <div id="perception-persons-list" style="margin-top:4px;"></div>
        <div style="display:flex; gap:4px; margin-top:6px; align-items:center;">
          <input type="text" id="inject-person-name" placeholder="人物名稱"
            style="flex:1; padding:4px 8px; font-size:12px; background:var(--bg); color:var(--text); border:1px solid var(--panel-border); border-radius:3px; outline:none;">
          <button class="btn-sm" id="btn-inject-person">注入</button>
        </div>
      </div>
    </div>

    <!-- 主動對話 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="proactive-panel-body">
        <h3>主動對話</h3>
        <span class="toggle-icon open">&#9654;</span>
      </div>
      <div class="collapsible-body open" id="proactive-panel-body">
        <div style="display:flex; align-items:center; gap:6px; margin-top:4px; font-size:12px;">
          <label style="cursor:pointer; display:flex; align-items:center; gap:4px;">
            <input type="checkbox" id="proactive-enabled" checked style="accent-color:var(--accent);">
            啟用主動觸發
          </label>
        </div>
        <div style="display:flex; gap:6px; margin-top:6px; align-items:center; font-size:11px;">
          <span style="color:var(--text-dim);">冷卻:</span>
          <input type="number" id="proactive-cooldown" value="30" min="1" max="600" step="1"
            style="width:50px; padding:2px 4px; font-size:11px; background:var(--bg); color:var(--text); border:1px solid var(--panel-border); border-radius:3px;">
          <span style="color:var(--text-dim);">s</span>
          <span style="color:var(--text-dim); margin-left:4px;">閒置:</span>
          <input type="number" id="proactive-idle-timeout" value="120" min="1" max="600" step="1"
            style="width:50px; padding:2px 4px; font-size:11px; background:var(--bg); color:var(--text); border:1px solid var(--panel-border); border-radius:3px;">
          <span style="color:var(--text-dim);">s</span>
          <button class="btn-sm" id="btn-proactive-update">更新</button>
        </div>
        <div class="info-row" style="margin-top:4px;">
          <span class="label">觸發:</span> <span id="proactive-last-trigger">--</span>
        </div>
        <div id="chat-history-area"
          style="max-height:120px; overflow-y:auto; margin-top:6px; padding:4px; background:var(--bg); border-radius:4px; font-size:11px; line-height:1.5;">
          <div style="color:var(--text-dim);">(尚無對話)</div>
        </div>
        <div style="display:flex; gap:4px; margin-top:6px;">
          <input type="text" id="chat-input" placeholder="對機器人說話..."
            style="flex:1; padding:4px 8px; font-size:12px; background:var(--bg); color:var(--text); border:1px solid var(--panel-border); border-radius:3px; outline:none;">
          <button class="btn-sm" id="btn-chat-send" style="background:var(--text-highlight); color:var(--bg); border-color:var(--text-highlight); font-weight:600;">送出</button>
        </div>
      </div>
    </div>

    <!-- 語音對話 -->
    <div class="panel-section">
      <div class="collapsible-header" data-target="voice-panel-body">
        <h3>語音對話</h3>
        <span class="toggle-icon open">&#9654;</span>
      </div>
      <div class="collapsible-body open" id="voice-panel-body">
        <!-- 狀態指示 -->
        <div style="margin-top:4px; margin-bottom:6px; display:flex; align-items:center; gap:6px; font-size:12px;">
          <span>狀態：</span>
          <span id="voiceStatus" style="font-weight:bold;">閒置</span>
          <span id="voiceIndicator" style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#888;"></span>
        </div>

        <!-- 開始/停止按鈕 -->
        <div class="btn-group" style="margin-bottom:6px;">
          <button onclick="startVoice()" id="btnStartVoice">開始監聽</button>
          <button onclick="stopVoice()" id="btnStopVoice" disabled>停止</button>
        </div>

        <!-- 最近辨識 -->
        <div style="margin-bottom:4px;">
          <div style="font-size:11px;color:var(--text-dim);">最近辨識：</div>
          <div id="lastTranscript" style="font-style:italic;color:var(--text-dim);font-size:12px;">—</div>
        </div>

        <!-- AI 回應 -->
        <div style="margin-bottom:6px;">
          <div style="font-size:11px;color:var(--text-dim);">AI 回應：</div>
          <div id="lastAIResponse" style="color:var(--text);font-size:12px;">—</div>
          <div id="lastEmotion" style="font-size:11px;color:var(--text-dim);">—</div>
        </div>

        <!-- 手動輸入（備用） -->
        <div style="display:flex;gap:4px;">
          <input type="text" id="voiceTextInput" placeholder="手動輸入..."
                 style="flex:1;padding:4px 8px;font-size:12px;background:var(--bg);color:var(--text);border:1px solid var(--panel-border);border-radius:3px;outline:none;"
                 onkeydown="if(event.key==='Enter' && !event.isComposing){sendVoiceText();}">
          <button class="btn-sm" onclick="sendVoiceText()">發送</button>
        </div>
      </div>
    </div>

    <!-- 行事曆 -->
    <div class="panel-section" id="calendar-section">
      <h3>行事曆</h3>
      <div id="calendar-list"></div>
    </div>

    <!-- 人物 -->
    <div class="panel-section" id="persons-section">
      <h3>辦公室人物</h3>
      <div id="persons-list"></div>
    </div>

    <!-- 事件日誌 -->
    <div class="event-log" id="event-log">
      <div class="event cat-system">
        <span class="event-time">[--:--]</span>
        <span class="event-msg">等待連線...</span>
      </div>
    </div>

    <!-- 說話輸入 -->
    <div class="speak-input">
      <input type="text" id="speak-text" placeholder="對機器人說話..." maxlength="200">
      <button id="btn-speak">送出</button>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════
// Reachy Mini 模擬器 Web 前端
// ═══════════════════════════════════════════════════════════════════

(function() {
'use strict';

// ── 常數 ────────────────────────────────────────────────────────
const CELL_SIZE = 40;
const CELL_COLORS = {
  0: '#3c3f46', // EMPTY
  1: '#505562', // WALL
  2: '#8caac8', // DOOR
  3: '#786446', // DESK
  4: '#64825a', // CHAIR
  5: '#ffdc3c', // CHARGER
};
const CELL_NAMES = {
  0: '空地', 1: '牆壁', 2: '門', 3: '桌子', 4: '椅子', 5: '充電站',
};
const WALKABLE = new Set([0, 2, 5]);

// ── 狀態 ────────────────────────────────────────────────────────
let mapData = null;
let currentState = null;
let ws = null;
let wsReconnectTimer = null;
let frameCount = 0;
let animationId = null;

// ── DOM 元素 ────────────────────────────────────────────────────
const canvas = document.getElementById('map-canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('cell-tooltip');
const eventLog = document.getElementById('event-log');
const wsIndicator = document.getElementById('ws-indicator');

// ── 地圖載入 ────────────────────────────────────────────────────
async function loadMap() {
  try {
    const resp = await fetch('/api/map');
    mapData = await resp.json();
    canvas.width = mapData.width * CELL_SIZE;
    canvas.height = mapData.height * CELL_SIZE;
  } catch (e) {
    console.error('無法載入地圖:', e);
  }
}

// ── WebSocket 連線 ──────────────────────────────────────────────
function connectWS() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${protocol}//${location.host}/ws`);

  ws.onopen = () => {
    wsIndicator.classList.add('connected');
    wsIndicator.title = 'WebSocket 已連線';
    if (wsReconnectTimer) {
      clearTimeout(wsReconnectTimer);
      wsReconnectTimer = null;
    }
  };

  ws.onclose = () => {
    wsIndicator.classList.remove('connected');
    wsIndicator.title = 'WebSocket 已斷線';
    wsReconnectTimer = setTimeout(connectWS, 2000);
  };

  ws.onerror = () => {
    ws.close();
  };

  ws.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      if (msg.type === 'state_update') {
        currentState = msg.state;
        updateUI(msg.state);
        if (msg.new_events && msg.new_events.length > 0) {
          appendEvents(msg.new_events);
        }
      }
    } catch (e) {
      console.error('WebSocket 訊息解析錯誤:', e);
    }
  };
}

// ── UI 更新 ────────────────────────────────────────────────────
function updateUI(state) {
  if (!state) return;

  // 時間
  document.getElementById('office-time').textContent = state.time.office_time;
  document.getElementById('sim-info').textContent =
    `模擬秒: ${Math.round(state.time.sim_time)}`;
  document.getElementById('speed-display').textContent =
    `${state.time.speed.toFixed(1)}x${state.time.paused ? ' [暫停]' : ''}`;

  // 機器人狀態
  const pos = state.robot.position;
  document.getElementById('robot-pos').textContent =
    `(${pos[0].toFixed(1)}, ${pos[1].toFixed(1)})`;

  const moveEl = document.getElementById('robot-move');
  if (state.nav_target) {
    moveEl.textContent = `\u2192 ${state.nav_target}`;
    moveEl.className = 'moving';
  } else {
    moveEl.textContent = '待命';
    moveEl.className = 'idle';
  }

  const ant = state.robot.antenna_pos_deg;
  document.getElementById('robot-ant').textContent =
    `L=${ant[1].toFixed(0)}\u00b0  R=${ant[0].toFixed(0)}\u00b0`;
  document.getElementById('robot-head').textContent =
    `yaw=${state.robot.head_yaw_deg.toFixed(0)}\u00b0  pitch=${state.robot.head_pitch_deg.toFixed(0)}\u00b0`;

  // 行事曆
  updateCalendar(state.calendar);

  // 人物
  updatePersons(state.persons);
}

function updateCalendar(cal) {
  const el = document.getElementById('calendar-list');
  if (!cal || !cal.meetings) {
    el.innerHTML = '<div class="meeting-item" style="color: var(--text-dim);">(無)</div>';
    return;
  }

  let html = '';
  if (cal.current) {
    html += `<div class="meeting-item current">&#9654; ${cal.current}</div>`;
  }
  if (cal.next) {
    html += `<div class="meeting-item next">&#9655; ${cal.next}</div>`;
  }
  if (!cal.current && !cal.next) {
    html += '<div class="meeting-item" style="color: var(--text-dim);">(今日無更多會議)</div>';
  }
  el.innerHTML = html;
}

function updatePersons(persons) {
  const el = document.getElementById('persons-list');
  if (!persons || Object.keys(persons).length === 0) {
    el.innerHTML = '<div class="person-item empty">(無人)</div>';
    return;
  }

  let html = '';
  for (const [name, p] of Object.entries(persons)) {
    html += `<div class="person-item">${name} @ (${p.position[0].toFixed(0)}, ${p.position[1].toFixed(0)})</div>`;
  }
  el.innerHTML = html;
}

function appendEvents(events) {
  for (const ev of events) {
    const div = document.createElement('div');
    div.className = `event cat-${ev.category || 'system'}`;
    div.innerHTML = `<span class="event-time">[${ev.time}]</span><span class="event-msg">${escapeHtml(ev.message)}</span>`;
    eventLog.appendChild(div);
  }
  eventLog.scrollTop = eventLog.scrollHeight;
}

function escapeHtml(text) {
  const d = document.createElement('div');
  d.textContent = text;
  return d.innerHTML;
}

// ── Canvas 繪製 ────────────────────────────────────────────────
function renderFrame() {
  animationId = requestAnimationFrame(renderFrame);
  if (!mapData) return;
  frameCount++;

  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  // 背景
  ctx.fillStyle = '#1e1e28';
  ctx.fillRect(0, 0, w, h);

  // 繪製格子
  for (let y = 0; y < mapData.height; y++) {
    for (let x = 0; x < mapData.width; x++) {
      const cell = mapData.grid[y][x];
      ctx.fillStyle = CELL_COLORS[cell] || '#3c3f46';
      ctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
    }
  }

  // 格線
  ctx.strokeStyle = '#32353c';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= mapData.width; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CELL_SIZE, 0);
    ctx.lineTo(x * CELL_SIZE, h);
    ctx.stroke();
  }
  for (let y = 0; y <= mapData.height; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CELL_SIZE);
    ctx.lineTo(w, y * CELL_SIZE);
    ctx.stroke();
  }

  // 具名位置標籤
  if (mapData.named_locations) {
    ctx.font = '11px -apple-system, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(180, 185, 200, 0.6)';
    for (const [name, loc] of Object.entries(mapData.named_locations)) {
      const lx = loc.position[0] * CELL_SIZE + CELL_SIZE / 2;
      const ly = loc.position[1] * CELL_SIZE - 3;
      ctx.fillText(name, lx, ly);
    }
  }

  if (!currentState) return;

  // 導航路徑
  if (currentState.nav_path && currentState.nav_path.length >= 2) {
    const pulse = Math.abs(Math.sin(frameCount * 0.06));
    ctx.strokeStyle = `rgba(80, 180, 255, ${0.3 + 0.2 * pulse})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < currentState.nav_path.length; i++) {
      const p = currentState.nav_path[i];
      const px = p[0] * CELL_SIZE + CELL_SIZE / 2;
      const py = p[1] * CELL_SIZE + CELL_SIZE / 2;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // 路徑點
    for (const p of currentState.nav_path) {
      const px = p[0] * CELL_SIZE + CELL_SIZE / 2;
      const py = p[1] * CELL_SIZE + CELL_SIZE / 2;
      ctx.fillStyle = `rgba(80, 180, 255, ${0.4 + 0.3 * pulse})`;
      ctx.beginPath();
      ctx.arc(px, py, 3 + pulse * 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // 人物
  if (currentState.persons) {
    for (const [name, person] of Object.entries(currentState.persons)) {
      const px = person.position[0] * CELL_SIZE + CELL_SIZE / 2;
      const py = person.position[1] * CELL_SIZE + CELL_SIZE / 2;
      const r = CELL_SIZE * 0.3;

      ctx.fillStyle = '#ffb43c';
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#c88a1e';
      ctx.lineWidth = 2;
      ctx.stroke();

      // 名稱
      ctx.font = '11px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#dce1e6';
      ctx.fillText(name, px, py + r + 12);
    }
  }

  // 機器人
  const rx = currentState.robot.position[0] * CELL_SIZE + CELL_SIZE / 2;
  const ry = currentState.robot.position[1] * CELL_SIZE + CELL_SIZE / 2;
  const bodyR = CELL_SIZE * 0.35;

  // 光暈
  const glowPulse = 0.7 + 0.3 * Math.abs(Math.sin(frameCount * 0.04));
  const glowR = CELL_SIZE * 0.6 * glowPulse;
  const gradient = ctx.createRadialGradient(rx, ry, 0, rx, ry, glowR);
  gradient.addColorStop(0, `rgba(50, 220, 120, ${0.3 * glowPulse})`);
  gradient.addColorStop(1, 'rgba(50, 220, 120, 0)');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(rx, ry, glowR, 0, Math.PI * 2);
  ctx.fill();

  // 主體
  ctx.fillStyle = '#32dc78';
  ctx.beginPath();
  ctx.arc(rx, ry, bodyR, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#1eb45a';
  ctx.lineWidth = 2;
  ctx.stroke();

  // 眼睛
  const eyeOffset = bodyR / 3;
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(rx - eyeOffset, ry - eyeOffset / 2, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(rx + eyeOffset, ry - eyeOffset / 2, 3, 0, Math.PI * 2);
  ctx.fill();

  // 天線
  const ant = currentState.robot.antenna_pos;
  for (let i = 0; i < 2; i++) {
    const sign = i === 0 ? -1 : 1;
    const angle = i === 0 ? ant[1] : ant[0];
    const ax = rx + sign * (bodyR * 0.5);
    const ay = ry - bodyR;
    const tipX = ax + sign * 6;
    const tipY = ay - 10 + angle * 8;

    ctx.strokeStyle = '#32dc78';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(tipX, tipY);
    ctx.stroke();

    ctx.fillStyle = '#64ffa0';
    ctx.beginPath();
    ctx.arc(tipX, tipY, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // 朝向指示器
  const headingRad = currentState.robot.heading * Math.PI / 180;
  const indDist = bodyR + 5;
  const indX = rx + Math.cos(headingRad) * indDist;
  const indY = ry - Math.sin(headingRad) * indDist;
  ctx.fillStyle = '#c8ffc8';
  ctx.beginPath();
  ctx.arc(indX, indY, 3, 0, Math.PI * 2);
  ctx.fill();
}

// ── 滑鼠互動 ──────────────────────────────────────────────────
let hoverCell = null;

canvas.addEventListener('mousemove', (e) => {
  if (!mapData) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  const gx = Math.floor(mx / CELL_SIZE);
  const gy = Math.floor(my / CELL_SIZE);

  if (gx >= 0 && gx < mapData.width && gy >= 0 && gy < mapData.height) {
    hoverCell = [gx, gy];
    const cell = mapData.grid[gy][gx];
    const cellName = CELL_NAMES[cell] || '?';
    const walkable = WALKABLE.has(cell);

    let tipText = `(${gx}, ${gy}) ${cellName}`;
    if (walkable) tipText += ' [可通行]';
    else tipText += ' [不可通行]';

    // 檢查具名位置
    for (const [name, loc] of Object.entries(mapData.named_locations || {})) {
      if (loc.position[0] === gx && loc.position[1] === gy) {
        tipText += ` - ${name}`;
        break;
      }
    }

    tooltip.textContent = tipText;
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 12) + 'px';
    tooltip.style.top = (e.clientY - 8) + 'px';
  } else {
    hoverCell = null;
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  hoverCell = null;
  tooltip.style.display = 'none';
});

// 左鍵點擊導航
canvas.addEventListener('click', (e) => {
  if (!mapData || !ws || ws.readyState !== WebSocket.OPEN) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  const gx = Math.floor(mx / CELL_SIZE);
  const gy = Math.floor(my / CELL_SIZE);

  if (gx >= 0 && gx < mapData.width && gy >= 0 && gy < mapData.height) {
    ws.send(JSON.stringify({ type: 'navigate', x: gx, y: gy }));
  }
});

// ── 控制按鈕 ────────────────────────────────────────────────────
function sendControl(action, value) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  const msg = { type: 'control', action };
  if (value !== undefined) msg.value = value;
  ws.send(JSON.stringify(msg));
}

document.getElementById('btn-pause').addEventListener('click', () => sendControl('pause'));
document.getElementById('btn-resume').addEventListener('click', () => sendControl('resume'));
document.getElementById('btn-reset').addEventListener('click', () => {
  sendControl('reset');
  eventLog.innerHTML = '';
});

document.getElementById('btn-speed-up').addEventListener('click', () => {
  if (currentState) {
    sendControl('speed', Math.min(currentState.time.speed + 0.5, 5.0));
  }
});

document.getElementById('btn-speed-down').addEventListener('click', () => {
  if (currentState) {
    sendControl('speed', Math.max(currentState.time.speed - 0.5, 0.5));
  }
});

// ── 說話輸入 ────────────────────────────────────────────────────
const speakInput = document.getElementById('speak-text');
const btnSpeak = document.getElementById('btn-speak');

function doSpeak() {
  const text = speakInput.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify({ type: 'speak', text, name: '使用者' }));
  speakInput.value = '';
}

btnSpeak.addEventListener('click', doSpeak);
speakInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.isComposing) doSpeak();
});

// ── Tab 切換 ────────────────────────────────────────────────────
const tabs = document.querySelectorAll('.tab-bar .tab');
const threeContainer = document.getElementById('three-container');

tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    tabs.forEach(t => t.classList.remove('active'));
    tab.classList.add('active');

    const tabName = tab.dataset.tab;
    if (tabName === '2d') {
      canvas.style.display = 'block';
      threeContainer.style.display = 'none';
    } else if (tabName === '3d') {
      canvas.style.display = 'none';
      threeContainer.style.display = 'block';
      if (typeof initThreeScene === 'function' && !window._threeInitialized) {
        initThreeScene();
        window._threeInitialized = true;
      }
    }
  });
});

// ── 可折疊面板 ────────────────────────────────────────────────────
document.querySelectorAll('.collapsible-header').forEach(header => {
  header.addEventListener('click', () => {
    const targetId = header.dataset.target;
    const body = document.getElementById(targetId);
    const icon = header.querySelector('.toggle-icon');
    if (body.classList.contains('open')) {
      body.classList.remove('open');
      icon.classList.remove('open');
    } else {
      body.classList.add('open');
      icon.classList.add('open');
    }
  });
});

// ── 喚醒/睡眠控制 ────────────────────────────────────────────────
let isAwake = true;

document.getElementById('btn-wake-sleep').addEventListener('click', async () => {
  const url = isAwake ? '/api/goto_sleep' : '/api/wake_up';
  try {
    const resp = await fetch(url, { method: 'POST' });
    const data = await resp.json();
    if (data.success) {
      isAwake = data.is_awake;
      updateWakeSleepBtn();
    }
  } catch (e) {
    console.error('wake/sleep error:', e);
  }
});

function updateWakeSleepBtn() {
  const btn = document.getElementById('btn-wake-sleep');
  btn.textContent = isAwake ? 'Go to Sleep' : 'Wake Up';
  if (isAwake) {
    btn.classList.remove('active-btn');
  } else {
    btn.classList.add('active-btn');
  }
}

// ── 馬達控制 ────────────────────────────────────────────────────
document.getElementById('motor-grid').addEventListener('change', async (e) => {
  if (e.target.type !== 'checkbox') return;
  const motorName = e.target.dataset.motor;
  const enabled = e.target.checked;
  try {
    await fetch('/api/motor', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ motor_name: motorName, enabled }),
    });
  } catch (err) {
    console.error('motor error:', err);
  }
});

// ── 插值控制 ────────────────────────────────────────────────────
const interpDuration = document.getElementById('interp-duration');
const interpDurationVal = document.getElementById('interp-duration-val');
interpDuration.addEventListener('input', () => {
  interpDurationVal.textContent = parseFloat(interpDuration.value).toFixed(1) + 's';
});

const interpYaw = document.getElementById('interp-yaw');
const interpYawVal = document.getElementById('interp-yaw-val');
interpYaw.addEventListener('input', () => {
  interpYawVal.textContent = interpYaw.value;
});

const interpPitch = document.getElementById('interp-pitch');
const interpPitchVal = document.getElementById('interp-pitch-val');
interpPitch.addEventListener('input', () => {
  interpPitchVal.textContent = interpPitch.value;
});

document.getElementById('btn-goto-target').addEventListener('click', async () => {
  const method = document.getElementById('interp-method').value;
  const duration = parseFloat(interpDuration.value);
  const yaw = parseFloat(interpYaw.value);
  const pitch = parseFloat(interpPitch.value);

  // 建構簡單的 4x4 旋轉矩陣 (Rz*Ry)
  const yr = yaw * Math.PI / 180;
  const pr = pitch * Math.PI / 180;
  const cy = Math.cos(yr), sy = Math.sin(yr);
  const cp = Math.cos(pr), sp = Math.sin(pr);
  const head = [
    [cy*cp, -sy, cy*sp, 0],
    [sy*cp,  cy, sy*sp, 0],
    [-sp,     0, cp,    0],
    [0,       0, 0,     1],
  ];

  try {
    await fetch('/api/goto_target', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ head, duration, method }),
    });
  } catch (err) {
    console.error('goto_target error:', err);
  }
});

// ── 音訊控制 ────────────────────────────────────────────────────
document.getElementById('btn-play-sound').addEventListener('click', async () => {
  try {
    await fetch('/api/play_sound', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ file_path: 'demo.wav' }),
    });
  } catch (err) {
    console.error('play_sound error:', err);
  }
});

let isRecordingAudio = false;
document.getElementById('btn-record-toggle').addEventListener('click', async () => {
  const action = isRecordingAudio ? 'stop' : 'start';
  try {
    const resp = await fetch('/api/record', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action }),
    });
    const data = await resp.json();
    if (data.success) {
      isRecordingAudio = data.is_recording;
      const btn = document.getElementById('btn-record-toggle');
      btn.textContent = isRecordingAudio ? 'Rec Stop' : 'Rec Start';
      if (isRecordingAudio) btn.classList.add('recording');
      else btn.classList.remove('recording');
    }
  } catch (err) {
    console.error('record error:', err);
  }
});

// ── 動作控制 ────────────────────────────────────────────────────
const motionSpeed = document.getElementById('motion-speed');
const motionSpeedVal = document.getElementById('motion-speed-val');
motionSpeed.addEventListener('input', () => {
  motionSpeedVal.textContent = parseFloat(motionSpeed.value).toFixed(1) + 'x';
});

let isRecordingMotion = false;
document.getElementById('btn-motion-rec-toggle').addEventListener('click', async () => {
  const action = isRecordingMotion ? 'stop_record' : 'start_record';
  try {
    const resp = await fetch('/api/motion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action }),
    });
    const data = await resp.json();
    if (data.success) {
      isRecordingMotion = !isRecordingMotion;
      const btn = document.getElementById('btn-motion-rec-toggle');
      btn.textContent = isRecordingMotion ? 'Rec Stop' : 'Rec Start';
      if (isRecordingMotion) btn.classList.add('recording');
      else btn.classList.remove('recording');
    }
  } catch (err) {
    console.error('motion rec error:', err);
  }
});

document.getElementById('btn-motion-play').addEventListener('click', async () => {
  const speed = parseFloat(motionSpeed.value);
  try {
    await fetch('/api/motion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'play', speed }),
    });
  } catch (err) {
    console.error('motion play error:', err);
  }
});

document.getElementById('btn-motion-stop').addEventListener('click', async () => {
  try {
    await fetch('/api/motion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'stop' }),
    });
  } catch (err) {
    console.error('motion stop error:', err);
  }
});

// ── 擴展 updateUI: 新增欄位 ─────────────────────────────────────
const _origUpdateUI = updateUI;
updateUI = function(state) {
  _origUpdateUI(state);
  if (!state) return;

  // 更新感知面板
  if (state.perception) {
    updatePerceptionPanel(state.perception);
  }
  // 更新主動對話面板
  if (state.proactive) {
    updateProactivePanel(state.proactive);
  }
  if (state.conversation) {
    updateConversationPanel(state.conversation);
  }
  // 更新語音面板
  if (state.voice) {
    updateVoicePanel(state.voice);
  }

  if (!state.robot) return;
  const r = state.robot;

  // 喚醒狀態
  if (r.is_awake !== undefined) {
    isAwake = r.is_awake;
    const awakeEl = document.getElementById('robot-awake');
    awakeEl.innerHTML = r.is_awake
      ? '<span class="status-dot on"></span>Awake'
      : '<span class="status-dot off"></span>Sleep';
    updateWakeSleepBtn();
  }

  // 馬達 checkbox 同步
  if (r.motor_states) {
    document.querySelectorAll('#motor-grid input[type="checkbox"]').forEach(cb => {
      const motor = cb.dataset.motor;
      if (motor in r.motor_states) {
        cb.checked = r.motor_states[motor];
      }
    });
  }

  // 音訊狀態
  if (r.is_sound_playing !== undefined) {
    document.getElementById('audio-sound-status').textContent =
      r.is_sound_playing ? 'Playing' : 'Idle';
  }
  if (r.is_recording !== undefined) {
    document.getElementById('audio-rec-status').textContent =
      r.is_recording ? 'Recording' : 'Idle';
  }

  // DoA (from IMU/sensor data)
  if (r.imu) {
    const acc = r.imu.accelerometer;
    const gyro = r.imu.gyroscope;
    const quat = r.imu.quaternion;
    document.getElementById('imu-accel').textContent =
      acc.map(v => v.toFixed(3)).join(', ');
    document.getElementById('imu-gyro').textContent =
      gyro.map(v => v.toFixed(3)).join(', ');
    document.getElementById('imu-quat').textContent =
      quat.map(v => v.toFixed(3)).join(', ');
  }

  // 關節角度
  if (r.joints) {
    document.getElementById('joint-head-roll').textContent = r.joints.head_roll.toFixed(1) + '\u00b0';
    document.getElementById('joint-head-pitch').textContent = r.joints.head_pitch.toFixed(1) + '\u00b0';
    document.getElementById('joint-head-yaw').textContent = r.joints.head_yaw.toFixed(1) + '\u00b0';
    document.getElementById('joint-ant-right').textContent = r.joints.antenna_right.toFixed(1) + '\u00b0';
    document.getElementById('joint-ant-left').textContent = r.joints.antenna_left.toFixed(1) + '\u00b0';
    document.getElementById('joint-body-yaw').textContent = r.joints.body_yaw.toFixed(1) + '\u00b0';
  }

  // 動作狀態
  if (r.is_motion_playing !== undefined) {
    document.getElementById('motion-status').textContent =
      r.is_motion_playing ? 'Playing' : 'Idle';
  }
};

// 異步載入 DoA
async function updateDoa() {
  try {
    const resp = await fetch('/api/doa');
    const data = await resp.json();
    if (data.doa !== undefined) {
      document.getElementById('audio-doa').textContent = data.doa.toFixed(1) + '\u00b0';
    }
  } catch (e) { /* ignore */ }
}
setInterval(updateDoa, 2000);

// ── 人物感知面板 ──────────────────────────────────────────────────
function updatePerceptionPanel(perception) {
  if (!perception) return;
  document.getElementById('perception-mode').textContent =
    perception.mode === 'mock' ? 'Script (Mock)' : perception.mode === 'yolo' ? 'YOLO' : '--';

  const statusEl = document.getElementById('perception-status');
  if (perception.person_visible) {
    statusEl.innerHTML = '<span class="status-dot on"></span>偵測到人物';
  } else {
    statusEl.innerHTML = '<span class="status-dot off"></span>無人';
  }

  document.getElementById('perception-count').textContent = perception.person_count;

  // 已偵測人物列表
  const listEl = document.getElementById('perception-persons-list');
  const persons = perception.persons || {};
  const names = Object.keys(persons);
  if (names.length === 0) {
    listEl.innerHTML = '';
  } else {
    let html = '';
    for (const name of names) {
      const pos = persons[name];
      const posStr = Array.isArray(pos) ? `(${pos[0].toFixed(2)}, ${pos[1].toFixed(2)})` : '';
      html += `<div style="display:flex; justify-content:space-between; align-items:center; font-size:11px; padding:1px 0;">`;
      html += `<span style="color:var(--person-color);">${escapeHtml(name)} ${posStr}</span>`;
      html += `<button class="btn-sm" onclick="removePerson('${escapeHtml(name)}')" style="padding:1px 6px; font-size:10px;">移除</button>`;
      html += `</div>`;
    }
    listEl.innerHTML = html;
  }
}

// 注入人物
document.getElementById('btn-inject-person').addEventListener('click', async () => {
  const nameInput = document.getElementById('inject-person-name');
  const name = nameInput.value.trim();
  if (!name) return;
  try {
    await fetch('/api/perception/inject', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, position: [0.5, 0.5] }),
    });
    nameInput.value = '';
  } catch (err) {
    console.error('inject person error:', err);
  }
});

document.getElementById('inject-person-name').addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.isComposing) {
    document.getElementById('btn-inject-person').click();
  }
});

// 移除人物（全域函式，供 onclick 呼叫）
window.removePerson = async function(name) {
  try {
    await fetch('/api/perception/remove', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name }),
    });
  } catch (err) {
    console.error('remove person error:', err);
  }
};

// ── 主動對話面板 ──────────────────────────────────────────────────
function updateProactivePanel(proactive) {
  if (!proactive) return;
  document.getElementById('proactive-enabled').checked = proactive.enabled;

  const triggerEl = document.getElementById('proactive-last-trigger');
  if (proactive.last_trigger_type) {
    triggerEl.textContent = proactive.last_trigger_type;
    triggerEl.style.color = 'var(--accent)';
  } else {
    triggerEl.textContent = '--';
    triggerEl.style.color = 'var(--text-dim)';
  }
}

function updateConversationPanel(conversation) {
  // 對話面板由 chat history API 驅動，此處僅做輕量指示更新
  // 更新語音面板的 AI 回應顯示
  if (conversation.last_response) {
    document.getElementById('lastAIResponse').textContent = conversation.last_response;
  }
  if (conversation.last_emotion) {
    document.getElementById('lastEmotion').textContent = '情緒: ' + conversation.last_emotion;
  } else {
    document.getElementById('lastEmotion').textContent = '—';
  }
}

// ── 語音對話面板 ──────────────────────────────────────────────────
function updateVoicePanel(v) {
  const statusEl = document.getElementById('voiceStatus');
  const indicator = document.getElementById('voiceIndicator');
  const statusMap = {
    'idle':       {text: '閒置',     color: '#888'},
    'listening':  {text: '監聽中...', color: '#4CAF50'},
    'processing': {text: '處理中...', color: '#FF9800'},
    'speaking':   {text: '說話中...', color: '#2196F3'},
  };
  const s = statusMap[v.status] || statusMap.idle;
  statusEl.textContent = s.text;
  indicator.style.background = s.color;

  if (v.last_transcript) {
    document.getElementById('lastTranscript').textContent = v.last_transcript;
  }

  // 同步按鈕狀態
  const listening = v.is_listening || false;
  document.getElementById('btnStartVoice').disabled = listening;
  document.getElementById('btnStopVoice').disabled = !listening;
}

window.startVoice = async function() {
  try {
    const r = await fetch('/api/voice/start', {method: 'POST'});
    const d = await r.json();
    if (d.success) {
      document.getElementById('btnStartVoice').disabled = true;
      document.getElementById('btnStopVoice').disabled = false;
    }
  } catch (err) {
    console.error('voice start error:', err);
  }
};

window.stopVoice = async function() {
  try {
    const r = await fetch('/api/voice/stop', {method: 'POST'});
    const d = await r.json();
    if (d.success) {
      document.getElementById('btnStartVoice').disabled = false;
      document.getElementById('btnStopVoice').disabled = true;
    }
  } catch (err) {
    console.error('voice stop error:', err);
  }
};

window.sendVoiceText = async function() {
  const input = document.getElementById('voiceTextInput');
  const text = input.value.trim();
  if (!text) return;
  input.value = '';
  try {
    await fetch('/api/chat', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({message: text}),
    });
  } catch (err) {
    console.error('voice text send error:', err);
  }
};

// 更新 proactive 設定
document.getElementById('btn-proactive-update').addEventListener('click', async () => {
  const enabled = document.getElementById('proactive-enabled').checked;
  const cooldown = parseFloat(document.getElementById('proactive-cooldown').value) || 30;
  const idleTimeout = parseFloat(document.getElementById('proactive-idle-timeout').value) || 120;
  try {
    await fetch('/api/proactive/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        enabled,
        greet_cooldown: cooldown,
        idle_timeout: idleTimeout,
      }),
    });
  } catch (err) {
    console.error('proactive config error:', err);
  }
});

document.getElementById('proactive-enabled').addEventListener('change', () => {
  document.getElementById('btn-proactive-update').click();
});

// 對話送出
const chatInput = document.getElementById('chat-input');
const btnChatSend = document.getElementById('btn-chat-send');

function doChatSend() {
  const text = chatInput.value.trim();
  if (!text) return;

  // 立即在 UI 顯示使用者訊息
  appendChatMessage('user', text);

  fetch('/api/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message: text, name: '使用者' }),
  }).catch(err => console.error('chat send error:', err));

  chatInput.value = '';
}

btnChatSend.addEventListener('click', doChatSend);
chatInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.isComposing) doChatSend();
});

function appendChatMessage(role, text, emotion) {
  const area = document.getElementById('chat-history-area');
  // 清除預設提示
  if (area.querySelector('div[style]') && area.children.length === 1 &&
      area.children[0].textContent.includes('尚無對話')) {
    area.innerHTML = '';
  }
  const div = document.createElement('div');
  div.style.padding = '1px 0';
  if (role === 'user') {
    div.style.color = 'var(--text)';
    div.innerHTML = `<span style="color:var(--accent-blue);">使用者:</span> ${escapeHtml(text)}`;
  } else {
    const emotionTag = emotion ? `<span style="color:var(--event-calendar);">[${escapeHtml(emotion)}]</span> ` : '';
    div.innerHTML = `<span style="color:var(--event-robot);">Robot:</span> ${emotionTag}${escapeHtml(text)}`;
  }
  area.appendChild(div);
  area.scrollTop = area.scrollHeight;
}

// 定時載入對話歷史
let lastChatCount = 0;
async function pollChatHistory() {
  try {
    const resp = await fetch('/api/chat/history');
    const data = await resp.json();
    if (data.history && data.history.length > lastChatCount) {
      const newEntries = data.history.slice(lastChatCount);
      for (const entry of newEntries) {
        if (entry.role === 'robot') {
          appendChatMessage('robot', entry.text, entry.emotion);
        } else if (entry.role === 'user' && lastChatCount > 0) {
          // 使用者訊息在送出時已即時顯示，只在初始載入時補
        }
      }
      lastChatCount = data.history.length;
    }
  } catch (e) { /* ignore */ }
}
setInterval(pollChatHistory, 1500);

// ── 初始化 ──────────────────────────────────────────────────────
async function init() {
  await loadMap();
  connectWS();
  renderFrame();

  // 初始載入事件
  try {
    const resp = await fetch('/api/events');
    const data = await resp.json();
    if (data.events) {
      eventLog.innerHTML = '';
      appendEvents(data.events);
    }
  } catch (e) {
    console.error('無法載入事件:', e);
  }
}

init();

// 全域暴露（供 3D 模組使用）
window._simState = () => currentState;
window._mapData = () => mapData;

})();
</script>

<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
// ═══════════════════════════════════════════════════════════════════
// 3D 視覺化場景 - Three.js
// ═══════════════════════════════════════════════════════════════════

function initThreeScene() {
'use strict';

const container = document.getElementById('three-container');
const UNIT = 1.0; // 每格 = 1 Three.js 單位

// ── 色彩 ────────────────────────────────────────────────────────
const COLORS = {
  floor:   0x2a2d36,
  wall:    0x505562,
  door:    0x6888a0,
  desk:    0x8b7355,
  chair:   0x5a7a50,
  charger: 0xccb030,
  robot:   0x32dc78,
  robotGlow: 0x50ff90,
  person:  0xffb43c,
  path:    0x50b4ff,
  ambient: 0x404060,
  grid:    0x32353c,
};

// ── 場景設定 ────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a24);
scene.fog = new THREE.FogExp2(0x1a1a24, 0.02);

const camera = new THREE.PerspectiveCamera(
  50, container.clientWidth / container.clientHeight, 0.1, 200
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
container.appendChild(renderer.domElement);

// ── 相機控制 ────────────────────────────────────────────────────
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI / 2.1;
controls.minDistance = 3;
controls.maxDistance = 40;

// 預設俯瞰位置
camera.position.set(10, 18, 14);
controls.target.set(10, 0, 6);
controls.update();

// ── 燈光 ────────────────────────────────────────────────────────
const ambientLight = new THREE.AmbientLight(COLORS.ambient, 0.6);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(15, 20, 10);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
scene.add(dirLight);

const hemiLight = new THREE.HemisphereLight(0x8888cc, 0x444422, 0.3);
scene.add(hemiLight);

// ── 地圖建構 ────────────────────────────────────────────────────
let mapBuilt = false;

function buildMap(mapData) {
  if (mapBuilt || !mapData) return;
  mapBuilt = true;

  const W = mapData.width;
  const H = mapData.height;

  // 地板
  const floorGeo = new THREE.PlaneGeometry(W * UNIT, H * UNIT);
  const floorMat = new THREE.MeshStandardMaterial({
    color: COLORS.floor, roughness: 0.9, metalness: 0.1
  });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set(W * UNIT / 2, -0.01, H * UNIT / 2);
  floor.receiveShadow = true;
  scene.add(floor);

  // 格線
  const gridHelper = new THREE.GridHelper(
    Math.max(W, H) * UNIT, Math.max(W, H),
    COLORS.grid, COLORS.grid
  );
  gridHelper.position.set(W * UNIT / 2, 0.01, H * UNIT / 2);
  gridHelper.material.opacity = 0.15;
  gridHelper.material.transparent = true;
  scene.add(gridHelper);

  // 遍歷 grid 建構 3D 物件
  const wallGeo = new THREE.BoxGeometry(UNIT * 0.95, 1.2, UNIT * 0.95);
  const wallMat = new THREE.MeshStandardMaterial({
    color: COLORS.wall, roughness: 0.7
  });

  const doorGeo = new THREE.BoxGeometry(UNIT * 0.9, 0.9, UNIT * 0.9);
  const doorMat = new THREE.MeshStandardMaterial({
    color: COLORS.door, roughness: 0.5, transparent: true, opacity: 0.7
  });

  const deskGeo = new THREE.BoxGeometry(UNIT * 0.85, 0.4, UNIT * 0.85);
  const deskMat = new THREE.MeshStandardMaterial({
    color: COLORS.desk, roughness: 0.6
  });

  const deskLegGeo = new THREE.BoxGeometry(0.05, 0.3, 0.05);
  const deskLegMat = new THREE.MeshStandardMaterial({
    color: 0x555555, roughness: 0.8
  });

  const chairSeatGeo = new THREE.BoxGeometry(UNIT * 0.5, 0.1, UNIT * 0.5);
  const chairBackGeo = new THREE.BoxGeometry(UNIT * 0.5, 0.35, 0.06);
  const chairMat = new THREE.MeshStandardMaterial({
    color: COLORS.chair, roughness: 0.6
  });

  const chargerGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.5, 8);
  const chargerMat = new THREE.MeshStandardMaterial({
    color: COLORS.charger, roughness: 0.3, metalness: 0.5,
    emissive: COLORS.charger, emissiveIntensity: 0.3,
  });

  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const cell = mapData.grid[y][x];
      const px = x * UNIT + UNIT / 2;
      const pz = y * UNIT + UNIT / 2;

      if (cell === 1) { // WALL
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.set(px, 0.6, pz);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
      }
      else if (cell === 2) { // DOOR
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(px, 0.45, pz);
        scene.add(door);
      }
      else if (cell === 3) { // DESK
        // 桌面
        const desk = new THREE.Mesh(deskGeo, deskMat);
        desk.position.set(px, 0.4, pz);
        desk.castShadow = true;
        scene.add(desk);
        // 桌腳
        const offsets = [[-0.3, -0.3], [0.3, -0.3], [-0.3, 0.3], [0.3, 0.3]];
        for (const [ox, oz] of offsets) {
          const leg = new THREE.Mesh(deskLegGeo, deskLegMat);
          leg.position.set(px + ox, 0.15, pz + oz);
          scene.add(leg);
        }
      }
      else if (cell === 4) { // CHAIR
        // 坐墊
        const seat = new THREE.Mesh(chairSeatGeo, chairMat);
        seat.position.set(px, 0.25, pz);
        seat.castShadow = true;
        scene.add(seat);
        // 椅背
        const back = new THREE.Mesh(chairBackGeo, chairMat);
        back.position.set(px, 0.45, pz - 0.22);
        back.castShadow = true;
        scene.add(back);
      }
      else if (cell === 5) { // CHARGER
        const charger = new THREE.Mesh(chargerGeo, chargerMat);
        charger.position.set(px, 0.25, pz);
        charger.castShadow = true;
        scene.add(charger);

        // 充電指示燈
        const indicatorGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const indicatorMat = new THREE.MeshStandardMaterial({
          color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0
        });
        const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
        indicator.position.set(px, 0.55, pz);
        scene.add(indicator);
      }
    }
  }
}

// ── 機器人 3D 模型 ──────────────────────────────────────────────
const robotGroup = new THREE.Group();
scene.add(robotGroup);

// 身體（圓柱）
const bodyGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.5, 16);
const bodyMat = new THREE.MeshStandardMaterial({
  color: COLORS.robot, roughness: 0.4, metalness: 0.3,
});
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.position.y = 0.35;
body.castShadow = true;
robotGroup.add(body);

// 頭（球）
const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
const headMat = new THREE.MeshStandardMaterial({
  color: COLORS.robot, roughness: 0.3, metalness: 0.2,
});
const head = new THREE.Mesh(headGeo, headMat);
head.position.y = 0.8;
head.castShadow = true;
robotGroup.add(head);

// 眼睛
const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
const eyeMat = new THREE.MeshStandardMaterial({
  color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.8
});
const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
leftEye.position.set(-0.1, 0.82, 0.2);
robotGroup.add(leftEye);

const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
rightEye.position.set(0.1, 0.82, 0.2);
robotGroup.add(rightEye);

// 天線
const antennaMat = new THREE.MeshStandardMaterial({
  color: COLORS.robot, roughness: 0.5
});
const antennaTipMat = new THREE.MeshStandardMaterial({
  color: COLORS.robotGlow, emissive: COLORS.robotGlow, emissiveIntensity: 0.5
});

// 左天線
const leftAntennaGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6);
const leftAntenna = new THREE.Mesh(leftAntennaGeo, antennaMat);
leftAntenna.position.set(-0.12, 1.1, 0);
robotGroup.add(leftAntenna);

const leftTipGeo = new THREE.SphereGeometry(0.04, 8, 8);
const leftTip = new THREE.Mesh(leftTipGeo, antennaTipMat);
leftTip.position.set(-0.12, 1.28, 0);
robotGroup.add(leftTip);

// 右天線
const rightAntenna = new THREE.Mesh(leftAntennaGeo.clone(), antennaMat);
rightAntenna.position.set(0.12, 1.1, 0);
robotGroup.add(rightAntenna);

const rightTip = new THREE.Mesh(leftTipGeo.clone(), antennaTipMat);
rightTip.position.set(0.12, 1.28, 0);
robotGroup.add(rightTip);

// 機器人底部光暈
const glowGeo = new THREE.CircleGeometry(0.5, 32);
const glowMat = new THREE.MeshBasicMaterial({
  color: COLORS.robot, transparent: true, opacity: 0.15
});
const glow = new THREE.Mesh(glowGeo, glowMat);
glow.rotation.x = -Math.PI / 2;
glow.position.y = 0.02;
robotGroup.add(glow);

// ── 人物容器 ────────────────────────────────────────────────────
const personMeshes = {};

function getPersonMesh(name) {
  if (personMeshes[name]) return personMeshes[name];

  const group = new THREE.Group();

  // 身體圓柱
  const pBodyGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.6, 12);
  const pBodyMat = new THREE.MeshStandardMaterial({
    color: COLORS.person, roughness: 0.5
  });
  const pBody = new THREE.Mesh(pBodyGeo, pBodyMat);
  pBody.position.y = 0.4;
  pBody.castShadow = true;
  group.add(pBody);

  // 頭
  const pHeadGeo = new THREE.SphereGeometry(0.15, 12, 12);
  const pHeadMat = new THREE.MeshStandardMaterial({
    color: 0xffcc88, roughness: 0.6
  });
  const pHead = new THREE.Mesh(pHeadGeo, pHeadMat);
  pHead.position.y = 0.85;
  pHead.castShadow = true;
  group.add(pHead);

  // 名稱標籤（使用 Sprite）
  const labelCanvas = document.createElement('canvas');
  labelCanvas.width = 128;
  labelCanvas.height = 32;
  const lctx = labelCanvas.getContext('2d');
  lctx.fillStyle = '#ffffff';
  lctx.font = '18px sans-serif';
  lctx.textAlign = 'center';
  lctx.fillText(name, 64, 22);
  const labelTexture = new THREE.CanvasTexture(labelCanvas);
  const labelMat = new THREE.SpriteMaterial({
    map: labelTexture, transparent: true, opacity: 0.8
  });
  const label = new THREE.Sprite(labelMat);
  label.position.y = 1.15;
  label.scale.set(1.0, 0.25, 1);
  group.add(label);

  scene.add(group);
  personMeshes[name] = group;
  return group;
}

function removePersonMesh(name) {
  if (personMeshes[name]) {
    scene.remove(personMeshes[name]);
    delete personMeshes[name];
  }
}

// ── 導航路徑 ────────────────────────────────────────────────────
let pathLine = null;

function updatePathLine(navPath) {
  if (pathLine) {
    scene.remove(pathLine);
    pathLine.geometry.dispose();
    pathLine = null;
  }

  if (!navPath || navPath.length < 2) return;

  const points = navPath.map(p =>
    new THREE.Vector3(p[0] * UNIT + UNIT / 2, 0.1, p[1] * UNIT + UNIT / 2)
  );
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({
    color: COLORS.path, transparent: true, opacity: 0.6, linewidth: 2
  });
  pathLine = new THREE.Line(geometry, material);
  scene.add(pathLine);
}

// ── 動畫迴圈 ────────────────────────────────────────────────────
let threeFrame = 0;

function animate() {
  requestAnimationFrame(animate);
  threeFrame++;

  controls.update();

  const mapData = window._mapData();
  if (mapData && !mapBuilt) {
    buildMap(mapData);
  }

  const state = window._simState();
  if (state) {
    // 更新機器人位置
    const rp = state.robot.position;
    robotGroup.position.set(
      rp[0] * UNIT + UNIT / 2,
      0,
      rp[1] * UNIT + UNIT / 2
    );

    // 機器人朝向
    const headingRad = state.robot.heading * Math.PI / 180;
    robotGroup.rotation.y = headingRad;

    // 天線動畫
    const antL = state.robot.antenna_pos[1];
    const antR = state.robot.antenna_pos[0];
    leftAntenna.rotation.z = antL * 0.5;
    leftTip.position.y = 1.28 + antL * 0.1;
    rightAntenna.rotation.z = -antR * 0.5;
    rightTip.position.y = 1.28 + antR * 0.1;

    // 光暈呼吸效果
    const pulse = 0.1 + 0.08 * Math.sin(threeFrame * 0.04);
    glowMat.opacity = pulse;

    // 天線發光動畫
    const tipPulse = 0.3 + 0.3 * Math.sin(threeFrame * 0.06);
    antennaTipMat.emissiveIntensity = tipPulse;

    // 更新人物
    const currentPersonNames = new Set();
    if (state.persons) {
      for (const [name, person] of Object.entries(state.persons)) {
        currentPersonNames.add(name);
        const mesh = getPersonMesh(name);
        mesh.position.set(
          person.position[0] * UNIT + UNIT / 2,
          0,
          person.position[1] * UNIT + UNIT / 2
        );
        mesh.visible = true;
      }
    }
    // 移除不再可見的人物
    for (const name of Object.keys(personMeshes)) {
      if (!currentPersonNames.has(name)) {
        removePersonMesh(name);
      }
    }

    // 更新路徑
    updatePathLine(state.nav_path);
  }

  renderer.render(scene, camera);
}

// ── 視窗大小調整 ────────────────────────────────────────────────
window.addEventListener('resize', () => {
  if (container.style.display === 'none') return;
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

// 啟動動畫
animate();
}

// 暴露至全域供 tab 切換使用
window.initThreeScene = initThreeScene;
</script>

</body>
</html>
